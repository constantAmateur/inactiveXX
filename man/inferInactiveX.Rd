% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inferInactiveX.R
\name{inferInactiveX}
\alias{inferInactiveX}
\title{Infer which copy of X is inactivated}
\usage{
inferInactiveX(
  cnts,
  errRate = 0.1,
  logitCut = 3,
  pCut = 0.2,
  tauInit = 0.5,
  betaStart = 0.01,
  betaFac = 1.3,
  anchorCell = NULL,
  nStarts = 1000,
  tol = 1e-06,
  maxIter = 1000,
  tauDiffFrac = 0.1,
  tauDiffThresh = 0.05,
  tauDiffWarnOnly = FALSE,
  nParallel = 1,
  verbose = 1,
  ...
)
}
\arguments{
\item{cnts}{Usually the output of \code{\link{getAllelicExpression}}.  A GRanges of counts with refCount/altCount (matCount/patCount if pre-phased) with one row for each cell and SNP.}

\item{errRate}{Assumed all cause error rate.  10\% seems to be about the baseline, but can vary}

\item{logitCut}{Cells with probabilities (on logit) scale greater than this value are marked high confidence cells.}

\item{pCut}{Cells with p-value of excess discrepent counts under this value cannot be high confidence cells.}

\item{tauInit}{Initial guess for fraction of cells expressing maternal allele.}

\item{betaStart}{Initial beta to use for deterministic annealing.}

\item{betaFac}{How much to increase beta by in each pass through the deterministic annealing loop.}

\item{anchorCell}{ID of cell assumed to be maternally active.  If NULL, one with highest coverage used.}

\item{nStarts}{How many times to run the fit starting at random locations.}

\item{tol}{EM terminated when change in Q less than this value.}

\item{maxIter}{Terminate EM if more than this many iterations.}

\item{tauDiffFrac}{Sanity check performed using the top \code{tauDiffFrac} of fits.}

\item{tauDiffThresh}{Sanity check failed when the fractional difference in tau exceeds this value.}

\item{tauDiffWarnOnly}{If we fail the tauDiff check (see details), throw a warning instead of an error.}

\item{nParallel}{How many threads?}

\item{verbose}{Be verbose?  Levels are 0 (off), 1 (outer loop), 2 (beta loop), 3 (EM loop)}

\item{...}{Extra parameters passed to \code{\link{mclapply}}.}
}
\value{
A list with \code{states}, indicating which allele is active, \code{genotype} indicating if the reference allele is maternal for each SNP, \code{tau} the fraction of cells with maternal active, \code{allFits} which contains results for each of the \code{nStarts} random initiations, \code{cellSummary} which contains summary stats for each cell, \code{snpSummary} which contains summary stats for each SNP, and \code{dd} which contains the raw data.
}
\description{
Given counts on the X chromosome, use EM to simultaneously estimate the genotype of the X chromosome and which version is inactivated in each cell.  If \code{cnts} includes columns \code{matCount} and \code{patCount}, the genotypes are assumed to have already been phased and rather than estimating the genotype, the genotype is assumed.
}
\details{
To ensure consistency of results, one cell (the \code{anchorCell}) is assumed to be in the maternally active state.  If not specified, this is picked to be the cell with the highest X chromosome coverage.

The summary stats provided at the cell/SNP level essentially assume the other part of the data is correct and then measure how discrepent each cell or SNP is.  For example, the cell summary stats assumes all SNPs have been correctly phased and then measures how many reads are in conflict with this phasing across each cell.

For samples with few cells and an extreme fraction of cells in one X-Inactivation state, it may not be possible to accurately estimate the genotype and X-Inactivation state of each cell.  However, in this situation the best fits across all random starts form show a trend where more extreme \code{tau} values (fraction of cells in one X-Inactivation state) always result in a better fit.  By contrast, where the best fit is well captured the top fits all cluster strongly around the same value.  

This difference can be seen visually with \code{\link{plotSolutions}}, but the code will attempt to automatically detect when the fit should be more extreme.  This is done by calculating the difference between the best fit value of \code{tau} and the the top \code{tauDiffFrac*maxIter} best fits (divided by the best fit \code{tau}) and reporting when this difference exceeds \code{tauDiffThresh}.  The intuition here is that when the top fits all cluster around one value the average difference will be basically 0.
}
